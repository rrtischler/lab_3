#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "ezdsp5502.h"
#include <stdio.h>
#include "Dsplib.h"
/**
 * main.c
 */
#define UPPERLIMIT 0x7FFF
#define LOWERLIMIT 0x8000
#define BUFFERSIZE    1
#define FS  16000
#define OFFSET 200
#define ATT 0x4000 //0.5 em q15
#define NUMNEWSAMPLES 2048
#define FREQUENCIAAMOSTRAGEM 2048
#define Q 15
#define K (1 << (Q - 1))

    Int16 samples[NUMNEWSAMPLES];
    Int16 outSample[NUMNEWSAMPLES];

    Uint8 buffer[BUFFERSIZE];

    Uint16 maxIn = 0;
    Uint16 maxOut = 0;
    DATA input[NUMNEWSAMPLES];
    char line[16];


void zerarBuffers();
void readTXT();
Int16 CalcBin();
Int16 soma(Int16 a, Int16 b);
Int16 q_mul(Int16 a, Int16 b);
Int16 sat16(Int32 r);


int main(void){
    zerarBuffers();
//    fft();
    readTXT();
    Int16 bin = CalcBin();
//    printf("%d", bin);

    return 0;
}

void readTXT(){
    FILE *inFile;
    inFile = fopen("..\\Data\\dataQ15_2048.txt", "rb");
    if (inFile == NULL){
      printf("Can't open dataQ15_2048.txt");
      return;
    }else{printf("entrou\n");}

    Uint16 i = 0, j, count = 0;

    while (fgets(line, sizeof(line), inFile)) {
        i++;
        input[i] = (Int16)((Int8)(line & 0xFF)) << 8;
        /* note that fgets don't strip the terminating \n, checking its
           presence would allow to handle lines longer that sizeof(line) */
        printf("%s",line);
        printf(" %d", input[i]);
    }

//    while( (fread(buffer, sizeof(Int16), BUFFERSIZE, inFile) == BUFFERSIZE ) ) {

//        samples[i++] = buffer[0];//(Int16)((Int8)((buffer[0] ^ 0x80) & 0xFF)) << 8 ;
//        if (i%NUMNEWSAMPLES == 0){
//            delay((Int32)NUMNEWSAMPLES);
//            i = 0;
//            //escrever as amostras com efeito no arquivo de saida
//            for (j = 0; j < NUMNEWSAMPLES; j++){
//                // desloca 8 bits pra direita e alterna o bit de sinal, que no wav tá ao contrario
//                buffer[0] = (Int8)(outSample[j] >> 8) ^ 0x80;
//                fwrite(buffer, sizeof(Int8), 1, outFile);
//            }
//        }
//        count++;
//    }
//    printf("%d\n", count);
//    printf("%d %d ", samples[i]);

    fclose(inFile);
}
//Int16 THD(){
//    Int16 thd;
//
//    return thd;
//}

void zerarBuffers(){
    int i;
    for (i= 0; i < 2048; i++){
        samples[i] = 0;
        outSample[i] = 0;
    }
}

//void fft(){
////    rfft(data, NUMNEWSAMPLES, SCALE);
//}

Int16 CalcBin(){
    Int16 bin = FREQUENCIAAMOSTRAGEM/NUMNEWSAMPLES;
    return bin;
}

Int16 soma(Int16 a, Int16 b){
    long r;
    r = (Int32)a + (Int32)b;
    return sat16(r);
}

Int16 sat16(Int32 r){
    if ( r > UPPERLIMIT)
        r = UPPERLIMIT;
    else if (r < (Int16)-0x8000)
        r = (Int16)-0x8000;
    return (Int16)r;
}

Int16 q_mul(Int16 a, Int16 b){
    Int16 result;
    Int32 temp;
    temp = (Int32)a * (Int32)b; // result type is operand's type
    // Rounding; mid values are rounded up
    temp += K;
    // Correct by dividing by base and saturate result
    result = sat16(temp >> Q);
    return result;
}
